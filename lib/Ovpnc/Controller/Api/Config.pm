package Ovpnc::Controller::Api::Config;
use XML::Simple;
use XML::SAX::ParserFactory;
use XML::Validator::Schema;
use Tie::IxHash;
use File::Copy;
use Readonly;
use strict;
use warnings;
use Moose;
use aliased 'Ovpnc::Controller::Api::Config::RenewCiphers' => 'RCPHR';
Readonly::Scalar my $SKIP_LINE => '^[;|#].*|^$';

BEGIN { extends 'Catalyst::Controller::REST'; }



=head1 NAME

Ovpnc::Controller::Api::Config - Catalyst Controller

=head1 DESCRIPTION

Catalyst Controller

OpenVPN Config Controller API


=head1 METHODS

=head2 base

For chain to login page

=cut

sub base : Chained('/base') PathPrefix CaptureArgs(0) {}


=head2 index

For REST action class

=cut

sub index :Chained('/') PathPart('api/config/') Args(0) :ActionClass('REST') { }


# Grouped actions
=head2 config_GET

Will output the configuration 
of openvpn and will run validation
just incase someone makes changes
in the conf file manually

=cut
{
	sub view_config : Chained('base') PathPart('show') Args(0)
	{
	    my ($self, $c) = @_;
	    $c->response->status(200);	

		my $format = $c->request->params->{format} ||= undef;
		my $current_conf = $self->get_openvpn_config_file( $c->config->{ovpnc_conf} );

		die "No configuration file specified! " unless $current_conf;

		my $output = $self->parse_conf_file(
			$current_conf,
			$format
		);

		if ( ref $output and defined $output->{error} ){
	        $c->response->status(200);
			$c->stash( { error => "Error reading configuration: " . $output->{error} } );
			$c->forward("View::JSON");
			return;
		}
		else {
			my $_data = $self->conf_to_xml(
				$output,
				{
					name => $self->get_openvpn_node_name( $c->config->{ovpnc_conf} ),
					file => $current_conf
				}
			);

			my $xml_data = $self->create_xml($_data);			
			if ( ref $xml_data and defined $xml_data->{error} ){
	   		    $c->response->status(200);
				$c->stash( { error => "Error writing back-end xml configuration '".$c->config->{ovpnc_conf}."':\r\n" . $xml_data->{error} } );
				$c->forward("View::JSON");
				return;
			}
			if (my $msg = $self->validate_xml($xml_data, $c->config->{ovpnc_config_schema}) ){
				$c->stash( { error => $msg } );
			}
			else {
				$c->stash( { status => $_data } );
			}
		}
	}

=head2 config_POST

When user posts data to this controller
this will update the configurtion files
of openvpn and the back-end xml
and run validataions via the xsd schema

=cut
	sub update_config : Chained('base') PathPart('update') Args(0)
	{
	    my ($self, $c) = @_;

	    unless ($c->request->method eq 'POST'){
	        $c->response->body( 'Not a POST method: ' . $c->request->method );
	        $c->response->status(500);
			return;
	    }

		# Set default response
	    $c->response->status(200);	

		# Dereference
		my %data = %{$c->request->params};

		# This will only prepare a data
		# structure which can be serialized
		# to XML
		my $xml = $self->create_xml( \%data );

		if ( not defined $xml  ){
			$c->stash( { error => 'Could not generate XML format from posted parameters' } );
			$c->forward("View::JSON");
			return;
		}

		# Create a string from
		# the xml object
		my $xml_string = XMLout(
			$xml,
			KeepRoot => 1,
	        NoSort => 0,
	        XMLDecl => "<?xml version='1.0' encoding='UTF-8'?>",
		) or die "Cannot generate XML data!";

		# Validate the xml against the xsd schema
		# Will return a message if any error
		my $message = $self->validate_xml($xml_string, $c->config->{ovpnc_config_schema});

		if ($message){
			$c->stash({ error => $message });
		} else {
			my $st_msg = {};
			my $config_file = $data{'-1_null_Config-File'};

			# Pretty fatal, but should not happen here
			# because we ran validation earlier on xml format
			unless ( $config_file ){
				$st_msg->{error} = "Did not receive any configuration file value!";
				$c->stash( $st_msg );
				$c->forward("View::JSON");
				return;
			}

			# Prepare configuration file header
			my $output = "#\n# OpenVPN Configuration file\n"
					   . "# Generated by " . __PACKAGE__ . "\n"
					   . "# Created: " . scalar localtime() . "\n"
					   . "# Do not modify by hand!\n"
					   . "#\n";

			# Cut out the directory name
			my ($dir) = $config_file =~ /^(.*)\/(.*)$/g;

			# Now check if directory is valid
			unless ( -e $dir and -d $dir and -w $dir ){
				$st_msg->{error} = "Error: Directory of configuration file is invalid: $!";
			}

			# Create backup for existing configuration file
			if ( -e $config_file ){
				copy($config_file, $config_file . '_' .time() .'_backup')
					or $st_msg->{error} = "Error: Cannot backup existing configuration file: $!";
			}

			my $FILE;
			# Open the (new) file for writing
			unless ( defined $st_msg->{error}){
				open($FILE, ">", $config_file)
					or $st_msg->{error} = "Error: Configuration file could not be updated: $!";
			}
		
			# If no errors so far, proceed
			# with outputing key/values to file		
			unless (defined $st_msg->{error}){
				$output .= $self->prepare_conf_file_data( \%data );
				print $FILE $output;
				close $FILE;
				if ( -e $c->config->{ovpnc_conf} && -w $c->config->{ovpnc_conf} ){
					XMLout(
		   		         $xml,
		   		         KeepRoot => 1,
		       		     NoSort => 0,
						 OutputFile => $c->config->{ovpnc_conf},
		      		     XMLDecl => "<?xml version='1.0' encoding='UTF-8'?>",
					) or die "Error generating xml configuration file: " . $!;
				}
				else {
					$st_msg->{error} = "Cannot write xml configuration file " 
									 . $c->config->{ovpnc_conf} 
									 . ".\r\nEither it does not exists or is not accessible.";
					$c->stash( $st_msg );
					$c->forward("View::JSON");
					return;
				}
				$st_msg->{status} = 'Configuration file updated successfully';
			}

			$c->stash( $st_msg );
		}
	}

=head2 renew_ciphers

Renew the Cipher list into the
XSD schema from openvpn

=cut

	sub renew_ciphers : Chained('base') PathPart('renew_ciphers') Args(0)
	{
		my ($self, $c) = @_;

		# Send openvpn binary and the schema to be updated
		my $ret_val = RCPHR->action(
			$c->config->{ovpnc_config_schema},
			$c->config->{openvpn_bin}
		);

		$c->stash( { status => $ret_val } );
	}

}

=head2 XML example create_xml

<Nodes>
  <Node id="1">
    <Name></Name>
    <Config-File></Config-File>
    <Directives>
      <Group id="1">
        <Directive>
          <Name>local</Name>
          <Params>
            <VPN-Server>192.168.1.250</VPN-Server>
          </Params>
        </Directive>
        <Directive>
          <Name>duplicate-cn</Name>
        </Directive>
      </Group>
    </Directives>
  </Node>
</Nodes>

=cut

# Private functions
{

=head2 prepare_conf_file_data

Will prepare the openvpn
configuration file
will set attributes etc

=cut
	sub prepare_conf_file_data :Private
	{
		my $self = shift;
		my %data = %{(shift)};

		my $output = '';
		my $on_hold = {};
		my @existing_keys;

		for my $key (keys %data){
			# Split the key on _
			my ($group, $parent, $real, $number, $disabled) = split ('_', $key);

			# Skip the two main Directives
			# They have been assigned group 0
			# (config filename and servername)
			#next if ($real eq 'Name' or $real eq 'Config-File');
			next if ($group == 0);

			# If this is second (or more) value
			# we need to hold it until we can
			# append it to its first value(s)
			if ( $number && $real ne 'push' ){
				if ( $self->not_exists(\@existing_keys, $real) ) {
					#warn "Added $real to on_hold with value "  . $data{$key};
					$on_hold->{$real}  = {
						value => $data{$key},
						parent => $parent
					};
					next;
				}
			}

			# If this one has no number defined
			# check if we have pending values
			# to append from the $on_hold hashref
			if ( ! $number && $real ne 'push' ){
				if ( ref $on_hold eq 'HASH' ){
					for my $okey ( keys %{$on_hold} ){
						#warn "Compare $real and $okey while orig was " . $key;
						if ($okey eq $real){
							#warn "Matched $okey against $real, while \$on_hold->{$okey} is: " . $on_hold->{$okey}->{value}
							#. " and \$data{\$key} is " . $data{$key} ;
							$data{$key} .= ' ' . $on_hold->{$okey}->{value} . ';' . $parent . ';' . $on_hold->{$okey}->{parent};
							#delete $on_hold->{$okey};
						}
					}
				}	
			}
			
			# If key name already found,
			# append current value to it		
			if ($output =~ /\n\b$real\b/g && $real ne 'push'){
				$output =~ s/($real.*)(;.*)\n/$1 $data{$key} $2\n/g;
				$output =~ s/($real.*)\n/$1;$parent\n/;
			}
			else {
				my $tab = length($real) >= 5 ? "\t" x 6 : "\t" x 7;
				$tab =  "\t" x 4 if (length($real) > 10 );
				if ( defined $data{$key} ){
					# Create new key/value
					# output value only if exists
					# otherwise output only the key
					if ( $real eq $data{$key} ){
						$output .= $real . "$tab;" . $parent . "\n";
					} 
					else { 
						unless ( $on_hold->{$real}->{parent} ){
							$output .= $real . "$tab"  . $data{$key} . ";" . $parent . "\n";
						}
						else {
							$output .= $real . "$tab"  . $data{$key} . "\n";
						}

					}
					#warn "I just assigned $real to \$output";
					push (@existing_keys, $real);
				}
			}
		}
		$output .= ";END\n";
		return $output;
	}

=head2 not_exists

Checks if elemnt already exists
in the array, if yes, it returns
false so it will not be put into hold

=cut
	sub not_exists :Private
	{
		my ($self, $keys, $real) = @_;
		return 1 unless ref $keys eq 'ARRAY';
		if ($real ~~ @{$keys}){
			#warn "Do not hold: $real";
			return 0;
		}
		return 1;
	}

=head2 create_xml

This function will create 
xml file (conditional)
and return xml string

=cut
	sub create_xml :Private
	{
		my ( $self, $data, $xml_file ) = @_;

		my $xml_obj = XMLin('<Nodes></Nodes>',ForceArray => [ 'Nodes', 'Node' ]);
	
		my $i = 0;

		# Create first node id
		$xml_obj->{Nodes}->{Node}->{id} = '0';

		my $last_group = '-1';

		DATA:
		for my $key (sort keys %{$data}){

			# We shall increment $i only when group changes
			# we get all elements sorted in this loop

			my ($group, $parent, $real, $number, $status) = split('_',$key);
			
			$i = 0 if ( $group > $last_group );

			# Only if group is not '-1' which are directives
			# which do not appear in the conf file itself
			$xml_obj->{Nodes}->{Node}->{Directives}->{Group}->[ $group ]->{id} = $group
				unless ( $group eq '-1' );

			# Name and Config-File have no
			# parent because they are not
			# part of the config file itself
			if ( $group eq '-1' ){
				$xml_obj->{Nodes}->{Node}->{$real} = [ $data->{$key} ];
			}
			else {
				# Create the Name node
				my ($z, $skip) = 0;

				if ( $real ne 'push' ){
			NODES:	for ( @{$xml_obj->{Nodes}->{Node}->{Directives}->{Group}->[ $group ]->{Directive}} ){

						unless ( $_->{Name}->[0] ) {
							$z++;
							next NODES;
						}

						# Check if such a name already exists in the 
						# hash, if yes, append to its node
						# Otherwise it creates a new parent node
						# and not append to the previous similar one
						if ( $real eq $_->{Name}->[0] ){
							warn "1. Name node already exists: '$real', now with '".$data->{$key}."' at loop '$z', group '$group', now at loop '$i', appending to previous($z).";
							$xml_obj->{Nodes}
									   ->{Node}
										 ->{Directives}
										   ->{Group}->[ $group ]
										     ->{Directive}->[ $z ]
											   ->{Params}->[0]
												 ->{$parent} = [ $data->{$key} ];
							
							# Give $skip a value for later checks
							$skip++;
							last NODES;
						}
						$z++;
					}
				}

				# If $skip is not assigned this is a new
				# parent node, so create a new one
				if ( ! $skip ){
					warn "2. Creating Name node at $i with $real and group $group, \$skip is " . ( $skip ? $skip : '0' );
					$xml_obj->{Nodes}
							   ->{Node}
								 ->{Directives}
								   ->{Group}->[ $group ]
								     ->{Directive}->[ $i ]
									   ->{Name} = [ $real ];
					
				}

				# Create parameters node only if
				# the parameters exists, that means
				# that they are different than the $parent
				if ( $real ne $data->{$key} && ! $skip ){
					warn "3. Creating Params Node for $parent and value $data->{$key} by group $group, \$i is $i";
					$xml_obj->{Nodes}
							   ->{Node}
							     ->{Directives}
								   ->{Group}->[ $group ]
								     ->{Directive}->[ $i ]
									   ->{Params}->[0] = { $parent => [ $data->{$key} ] };
				}

				$i++ if ( ! $skip );

			}

			# Save the group for next loop
			$last_group = $group;

		}
		
		# Note! Returns a PERL data structure
		# we shall XMLout it soon
		return $xml_obj;
	}

=head2 validate_xml 

Validate the xml against a xsd schema
returns the errors if any

=cut
	sub validate_xml :Private
	{
		my ($self, $xml, $schema) = @_;
		my $validator = XML::Validator::Schema->new(file => $schema);
		my $parser = XML::SAX::ParserFactory->parser(Handler => $validator);
		eval { $parser->parse_string($xml) };
		return "Form validation error: $@" if $@;
	}

=head2 get_openvpn_config_file

Reads the back-end xml configuration

=cut
	sub get_openvpn_config_file :Private
	{
		my ($self, $file) = @_;
		my $xml_obj = XMLin($file) or die  "Cannot read xml file $file: $!";
		return $xml_obj->{Node}->{'Config-File'};
	}

=head2 get_openvpn_node_name

Reads the openvpn node name from
the back-end xml configuration

=cut
	sub get_openvpn_node_name :Private
	{
		my ($self, $file) = @_;
		my $xml_obj = XMLin($file) or die  "Cannot read xml file $file: $!";
		return $xml_obj->{Node}->{'Name'};
	}

=head2 conf_to_xml

Parse the configuration (keys/values)
into a xml ready to parse format

=cut
	sub conf_to_xml :Private
	{
		my ($self, $data, $conf_params) = @_;
		my $xml;

		for my $key ( keys %{$data} ){
			my $check_key = $data->{$key};
			my ($parents_full) = $data->{$key} =~ /;(.*)$/g;
			my @parents = split(';', $parents_full);
			$check_key =~ s/;.*$//;

			my @dirs = split (' ',$check_key);
			if ( $key !~ /push.*/ ){
				if ( @dirs > 1 ){
					if ($check_key){
						$xml->{$parents[0] . '_' . $key} = $dirs[0];
						for (my $i = 1; $i < @dirs; $i++){
							$xml->{$parents[$i] . '_' . $key . '_' . $i} = $dirs[$i]; 		
						}
					}
					else {
						$xml->{$parents[0] . '_' . $key} = $check_key;
					}
				}
				else {
					$xml->{$parents[0] . '_' . $key} = $dirs[0] ? $dirs[0] : $key;
				}
			}
			else {
				$xml->{$parents[0] . '_' . $key} = join " ", @dirs;
			}

		}
		
		# Append two last directives
		# for validation xslt
		$xml->{'null_Name'} = $conf_params->{name};
		$xml->{'null_Config-File'} = $conf_params->{file};

		return $xml;
	}

=head2 parse_conf_file

Parse the openvpn configuration file

=cut
	sub parse_conf_file :Private
	{
		my ($self, $file, $format) = @_;
		my $data = {};

		open ( FILE, "<", $file)
			or return { error => "Cannot open configuration file '$file' for reading: $!" };

		my $_pushed = 0;
		while (my $line = <FILE>){
			# Skip comments and empty lines
			next if ($line =~ /$SKIP_LINE/);

			# Get parent definition(s)
			#my (undef, @parents) = split(';', $line);
			
			# Remove end-of-line comments
			#$line =~ s/#.*$|;.*$//;
			$line =~ s/#.*$//;

			# Split by space into an array
			my (@arr) = split (' ', $line);
			next unless @arr;

			if ($arr[0] ne 'push'){
				# If only a key, set value to be the same
				if ( @arr == 1 ) {
					$data->{$arr[0]} = $arr[0];
				}
				else {
					my $k = shift @arr;
					$data->{$k} = join " ", @arr;
				}
			}
			else {
                my $k = shift @arr;
				if ($_pushed > 0){
	                $data->{$k.'_'.$_pushed} = join " ", @arr;
				}
				else {
	                $data->{$k} = join " ", @arr;
				}
				$_pushed++;
   			}
		}
		close FILE;
		return $data;
	}

}	

# Default functions
sub default :Private
{
    my ($self, $c) = @_;
    $c->stash( { status => 'Control action not found' } );
    $c->response->status(404);
}

sub end :Private
{
    my ($self, $c) = @_;

    # Debug if requested
    die "forced debug" if $c->req->params->{dump_info};

    # Forward to JSON view
	$c->forward( ( $c->request->params->{xml} ? 'View::XML::Simple' : 'View::JSON' ) );
}

=head1 AUTHOR

Nuriel Shem-Tov

=head1 LICENSE

This library is free software. You can redistribute it and/or modify
it under the same terms as Perl itself.

=cut

__PACKAGE__->meta->make_immutable(inline_constructor => 0);

1;
