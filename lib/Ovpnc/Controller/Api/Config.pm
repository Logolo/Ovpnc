package Ovpnc::Controller::Api::Config;
use XML::Simple;
use XML::SAX::ParserFactory;
use XML::Validator::Schema;
use Tie::IxHash;
use File::Copy;
use Readonly;
use strict;
use warnings;
use Moose;
Readonly::Scalar my $SKIP_LINE => '^[;|#].*|^$';

BEGIN { extends 'Catalyst::Controller::REST'; }


=head1 NAME

Ovpnc::Controller::Api::Config - Catalyst Controller

=head1 DESCRIPTION

Catalyst Controller

OpenVPN Config Controller API


=head1 METHODS


=head2 config

For REST action class

=cut

sub config : Path('/api/config') : ActionClass('REST') { }

{

=head2 config_GET

Will output the configuration 
of openvpn and will run validation
just incase someone makes changes
in the conf file manually

=cut
	sub config_GET
	{
	    my ($self, $c) = @_;
		my $format = $c->request->params->{format} ||= undef;


		my $current_conf = $self->get_openvpn_config_file( $c->config->{ovpnc_conf} );

		die "No configuration file specified! " unless $current_conf;

		my $output = $self->parse_conf_file(
			$current_conf,
			$format
		);

		if ( defined $output->{error} ){
			$c->response->body( "Error reading configuration: " . $output );
		    $c->response->status(500);
		}
		else {
			my $_data = $self->conf_to_xml(
				$output,
				{
					name => $self->get_openvpn_node_name( $c->config->{ovpnc_conf} ),
					file => $current_conf
				}
			);

			my $xml_data = $self->create_xml($_data);			
			if ( defined $xml_data->{error} ){
				$c->stash( { error => "Error writing back-end xml configuration '$c->config->{ovpnc_config_schema}':\r\n" . $xml_data->{error} } );
				$c->forward("View::JSON");
				return;
			}
			if (my $msg = $self->validate_xml($xml_data, $c->config->{ovpnc_config_schema}) ){
				$c->stash( { error => $msg } );
			}
			else {
				$c->stash( { status => $_data } );
			}
		}
	}

=head2 config_POST

When user posts data to this controller
this will update the configurtion files
of openvpn and the back-end xml
and run validataions via the xsd schema

=cut
	sub config_POST
	{
	    my ($self, $c) = @_;
	
	    unless ($c->request->method eq 'POST'){
	        $c->response->body( 'Not a POST method: ' . $c->request->method );
	        $c->response->status(500);
	    }

		my %data;
		tie %data, 'Tie::IxHash';

	    my $data = $c->request->params;
		my $xml = $self->create_xml( $data, $c->config->{ovpnc_conf} );
		if ( defined $xml->{error} ){
			$c->stash( { error => "Error writing back-end xml configuration file '".$c->config->{ovpnc_config_schema}."':\r\n" . $xml->{error} } );
			$c->forward("View::JSON");
			return;
		}
		%data = %{$data};

		# Validate the xml against the xsd schema
		# Will return a message if any error
		my $message = $self->validate_xml($xml, $c->config->{ovpnc_config_schema});

		if ($message){
			$c->stash({ error => $message });
		} else {
			my $st_msg = {};
			my $config_file = $data->{'null_Config-File'};

			# Pretty fatal, but should not happen here
			# because we ran validation earlier on xml format
			unless ($config_file){
				$st_msg->{error} = "Did not receive any configuration file value!";
	        	$c->response->status(500);
				$c->stash( $st_msg );
				$c->forward("View::JSON");
				return;
			}

			# Prepare configuration file header
			my $output = "#\n# OpenVPN Configuration file\n"
					   . "# Generated by " . __PACKAGE__ . "\n"
					   . "# Created: " . scalar localtime() . "\n"
					   . "# Do not modify by hand!\n"
					   . "#\n";

			# Cut out the directory name
			my ($dir) = $config_file =~ /^(.*)\/(.*)$/g;

			# Now check if directory is valid
			unless ( -e $dir and -d $dir and -w $dir ){
				$st_msg->{error} = "Error: Directory of configuration file is invalid: $!";
			}

			# Create backup for existing configuration file
			if ( -e $config_file ){
				copy($config_file, $config_file . '_' .time() .'_backup')
					or $st_msg->{error} = "Error: Cannot backup existing configuration file: $!";
			}

			my $FILE;
			# Open the (new) file for writing
			unless (defined $st_msg->{error}){
				open($FILE, ">", $config_file)
					or $st_msg->{error} = "Error: Configuration file could not be updated: $!";
			}
		
			# If no errors so far, proceed
			# with outputing key/values to file		
			unless (defined $st_msg->{error}){
				$output .= $self->prepare_conf_file_data( \%data );
				print $FILE $output;
				close $FILE;
				$st_msg->{status} = 'Configuration file updated successfully';
			}

			$c->stash( $st_msg );
		}
	}

}

=head2 XML example create_xml

<Nodes>
  <Node id="1">
    <Name></Name>
    <Config-File></Config-File>
    <Directives>
      <Group id="1">
        <Directive>
          <Name>local</Name>
          <Params>
            <VPN-Server>192.168.1.250</VPN-Server>
          </Params>
        </Directive>
        <Directive>
          <Name>duplicate-cn</Name>
        </Directive>
      </Group>
    </Directives>
  </Node>
</Nodes>

=cut

# Private functions
{

=head2 prepare_conf_file_data

Will prepare the openvpn
configuration file
will set attributes etc

=cut
	sub prepare_conf_file_data :Private
	{
		my $self = shift;
		my %data = %{(shift)};

		my $output = '';
		my $on_hold = {};
		my @existing_keys;

		for my $key (keys %data){
			# Split the key on _
			my ($parent, $real, $number) = split ('_', $key);

			# Skip the two main Directives
			# (config filename and servername)
			next if ($real eq 'Name' or $real eq 'Config-File');

			# If this is second (or more) value
			# we need to hold it until we can
			# append it to its first value(s)
			if ( $number && $real ne 'push' ){
				if ( $self->not_exists(\@existing_keys, $real) ) {
					#warn "Added $real to on_hold with value "  . $data{$key};
					$on_hold->{$real}  = {
						value => $data{$key},
						parent => $parent
					};
					next;
				}
			}

			# If this one has no number defined
			# check if we have pending values
			# to append from the $on_hold hashref
			if ( ! $number && $real ne 'push' ){
				if ( ref $on_hold eq 'HASH' ){
					for my $okey ( keys %{$on_hold} ){
						#warn "Compare $real and $okey while orig was " . $key;
						if ($okey eq $real){
							#warn "Matched $okey against $real, while \$on_hold->{$okey} is: " . $on_hold->{$okey}->{value}
							#. " and \$data{\$key} is " . $data{$key} ;
							$data{$key} .= ' ' . $on_hold->{$okey}->{value} . ';' . $parent . ';' . $on_hold->{$okey}->{parent};
							#delete $on_hold->{$okey};
						}
					}
				}	
			}
			
			# If key name already found,
			# append current value to it		
			if ($output =~ /\n\b$real\b/g && $real ne 'push'){
				$output =~ s/($real.*)(;.*)\n/$1 $data{$key} $2\n/g;
				$output =~ s/($real.*)\n/$1;$parent\n/;
			}
			else {
				my $tab = length($real) >= 5 ? "\t" x 6 : "\t" x 7;
				$tab =  "\t" x 4 if (length($real) > 10 );
				if ( defined $data{$key} ){
					# Create new key/value
					# output value only if exists
					# otherwise output only the key
					if ( $real eq $data{$key} ){
						$output .= $real . "$tab;" . $parent . "\n";
					} 
					else { 
						unless ( $on_hold->{$real}->{parent} ){
							$output .= $real . "$tab"  . $data{$key} . ";" . $parent . "\n";
						}
						else {
							$output .= $real . "$tab"  . $data{$key} . "\n";
						}

					}
					#warn "I just assigned $real to \$output";
					push (@existing_keys, $real);
				}
			}
		}
		$output .= ";END\n";
		return $output;
	}

=head2 not_exists

Checks if elemnt already exists
in the array, if yes, it returns
false so it will not be put into hold

=cut
	sub not_exists :Private
	{
		my ($self, $keys, $real) = @_;
		return 1 unless ref $keys eq 'ARRAY';
		if ($real ~~ @{$keys}){
			#warn "Do not hold: $real";
			return 0;
		}
		return 1;
	}

=head2 create_xml

This function will create 
xml file (conditional)
and return xml string

=cut
	sub create_xml :Private
	{
		my ( $self, $data, $xml_file ) = @_;

		my $xml_obj = XMLin('<Nodes></Nodes>',ForceArray => [ 'Nodes', 'Node' ]);
	
		my $i = 0;
	
		$xml_obj->{Nodes}->{Node}->{Directives}->{Group} = [];
		$xml_obj->{Nodes}->{Node}->{Directives}->{Group}->[0]->{id} = 1;

		DATA:
		for my $key (keys %{$data}){

			my ($parent, $real, $number) = split('_',$key);

			$xml_obj->{Nodes}->{Node}->{id} = 1;
	
			# Name and Config-File have no
			# parent because they are not
			# part of the config file itself
			if ($parent eq 'null'){
				$xml_obj->{Nodes}->{Node}->{$real} = [ $data->{$key} ];
			}
			else {
				# Create the Name node

				my ($z, $skip) = 0;
				if ( $real ne 'push' ){
				NODES:	for ( @{$xml_obj->{Nodes}->{Node}->{Directives}->{Group}->[0]->{Directive}} ){
						next NODES unless $_->{Name}->[0];
						if ($real eq $_->{Name}->[0]){
							#warn "1. Name node already exists: '$real' at loop '$z', now at loop '$i', appending to previous.";
							push (
								@{$xml_obj->{Nodes}->{Node}->{Directives}->{Group}->[0]->{Directive}->[$z]->{Params}->[0]->{$parent}},
								$data->{$key}
							);
							$skip++;
							last NODES;
						}
						$z++;
					}
				}
				unless ($skip){
					#warn "2. Creating Name node at $i with $real, \$skip is " . ( $skip ? $skip : '0' );
					$xml_obj->{Nodes}->{Node}->{Directives}->{Group}->[0]->{Directive}->[ $i ]->{Name} = [ $real ]
				}


				# Create parameters node only if
				# the parameters exists, that means
				# that they are different than the $parent
				#warn "'" . $real . "' against '" . $data->{$key} . "'";
				if ( $real ne $data->{$key} && not defined $skip ){
					#warn "3. Creating Params Node for $parent and value $data->{$key} \$i is $i";
					push (
						@{$xml_obj->{Nodes}->{Node}->{Directives}->{Group}->[0]->{Directive}->[$i]->{Params}->[0]->{$parent}},
						$data->{$key}
					);
				}
				$i++ unless $skip;

			}
		}

		# Write to file if defined
		# for viewing we also run
		# this generator but do
		# not output to file
        if ( defined $xml_file ){
			if ( -e $xml_file && -w $xml_file){
				XMLout(
	   		         $xml_obj,
	   		         KeepRoot => 1,
	       		     NoSort => 0,
					 OutputFile => $xml_file,
	      		     XMLDecl => "<?xml version='1.0' encoding='UTF-8'?>",
				) or die "Error generating xml configuration file: " . $!;
			}
			else {
				return { error => "Cannot write xml configuration file! Either it does not exists or is not accessible." };
			}
		}

		# Return XML data
		return XMLout(
			$xml_obj,
			KeepRoot => 1,
	        NoSort => 0,
	        XMLDecl     => "<?xml version='1.0' encoding='UTF-8'?>",
		);
	}

=head2 validate_xml 

Validate the xml against a xsd schema
returns the errors if any

=cut
	sub validate_xml :Private
	{
		my ($self, $xml, $schema) = @_;
		my $validator = XML::Validator::Schema->new(file => $schema);
		my $parser = XML::SAX::ParserFactory->parser(Handler => $validator);
		eval { $parser->parse_string($xml) };
		return "Form validation error: $@" if $@;
	}

=head2 get_openvpn_config_file

Reads the back-end xml configuration

=cut
	sub get_openvpn_config_file :Private
	{
		my ($self, $file) = @_;
		my $xml_obj = XMLin($file) or die  "Cannot read xml file $file: $!";
		return $xml_obj->{Node}->{'Config-File'};
	}

=head2 get_openvpn_node_name

Reads the openvpn node name from
the back-end xml configuration

=cut
	sub get_openvpn_node_name :Private
	{
		my ($self, $file) = @_;
		my $xml_obj = XMLin($file) or die  "Cannot read xml file $file: $!";
		return $xml_obj->{Node}->{'Name'};
	}

=head2 conf_to_xml

Parse the configuration (keys/values)
into a xml ready to parse format

=cut
	sub conf_to_xml :Private
	{
		my ($self, $data, $conf_params) = @_;
		my $xml;

		for my $key ( keys %{$data} ){
			my $check_key = $data->{$key};
			my ($parents_full) = $data->{$key} =~ /;(.*)$/g;
			my @parents = split(';', $parents_full);
			$check_key =~ s/;.*$//;

			my @dirs = split (' ',$check_key);
			if ( $key !~ /push.*/ ){
				if ( @dirs > 1 ){
					if ($check_key){
						$xml->{$parents[0] . '_' . $key} = $dirs[0];
						for (my $i = 1; $i < @dirs; $i++){
							$xml->{$parents[$i] . '_' . $key . '_' . $i} = $dirs[$i]; 		
						}
					}
					else {
						$xml->{$parents[0] . '_' . $key} = $check_key;
					}
				}
				else {
					$xml->{$parents[0] . '_' . $key} = $dirs[0] ? $dirs[0] : $key;
				}
			}
			else {
				$xml->{$parents[0] . '_' . $key} = join " ", @dirs;
			}

		}
		
		# Append two last directives
		# for validation xslt
		$xml->{'null_Name'} = $conf_params->{name};
		$xml->{'null_Config-File'} = $conf_params->{file};

		return $xml;
	}

=head2 parse_conf_file

Parse the openvpn configuration file

=cut
	sub parse_conf_file :Private
	{
		my ($self, $file, $format) = @_;
		my $data = {};

		open ( FILE, "<", $file)
			or return { error => "Error: Cannot open configuration file for reading: $!" };

		my $_pushed = 0;
		while (my $line = <FILE>){
			# Skip comments and empty lines
			next if ($line =~ /$SKIP_LINE/);

			# Get parent definition(s)
			#my (undef, @parents) = split(';', $line);
			
			# Remove end-of-line comments
			#$line =~ s/#.*$|;.*$//;
			$line =~ s/#.*$//;

			# Split by space into an array
			my (@arr) = split (' ', $line);
			next unless @arr;

			if ($arr[0] ne 'push'){
				# If only a key, set value to be the same
				if ( @arr == 1 ) {
					$data->{$arr[0]} = $arr[0];
				}
				else {
					my $k = shift @arr;
					$data->{$k} = join " ", @arr;
				}
			}
			else {
                my $k = shift @arr;
				if ($_pushed > 0){
	                $data->{$k.'_'.$_pushed} = join " ", @arr;
				}
				else {
	                $data->{$k} = join " ", @arr;
				}
				$_pushed++;
   			}
		}
		close FILE;
		return $data;
	}

}	

# Default functions
sub default :Private
{
    my ($self, $c) = @_;
    $c->stash( { status => 'Control action not found' } );
    $c->response->status(404);
}

sub end :Private
{
    my ($self, $c) = @_;

    # Debug if requested
    die "forced debug" if $c->req->params->{dump_info};

    # Forward to JSON view
	$c->forward( ( $c->request->params->{xml} ? 'View::XML::Simple' : 'View::JSON' ) );
}

=head1 AUTHOR

Nuriel Shem-Tov

=head1 LICENSE

This library is free software. You can redistribute it and/or modify
it under the same terms as Perl itself.

=cut

__PACKAGE__->meta->make_immutable(inline_constructor => 0);

1;
